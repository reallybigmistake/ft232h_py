from ctypes import *
from enum import Enum

FT_LIST_NUMBER_ONLY = 0x80000000
FT_LIST_BY_INDEX = 0x40000000
FT_LIST_ALL = 0x20000000


class FT_DEVICE(Enum):
    FT_DEVICE_BM = 0
    FT_DEVICE_AM = 1
    FT_DEVICE_100AX = 2
    FT_DEVICE_UNKNOWN = 3
    FT_DEVICE_2232C = 4
    FT_DEVICE_232R = 5
    FT_DEVICE_2232H = 6
    FT_DEVICE_4232H = 7
    FT_DEVICE_232H = 8
    FT_DEVICE_X_SERIES = 9
    FT_DEVICE_4222H_0 = 10
    FT_DEVICE_4222H_1_2 = 11
    FT_DEVICE_4222H_3 = 12
    FT_DEVICE_4222_PROG = 13
    FT_DEVICE_900 = 14
    FT_DEVICE_930 = 15
    FT_DEVICE_UMFTPD3A = 16


class STATUS(Enum):
    FT_OK = 0
    FT_INVALID_HANDLE = 1
    FT_DEVICE_NOT_FOUND = 2
    FT_DEVICE_NOT_OPENED = 3
    FT_IO_ERROR = 4
    FT_INSUFFICIENT_RESOURCES = 5
    FT_INVALID_PARAMETER = 6
    FT_INVALID_BAUD_RATE = 7

    FT_DEVICE_NOT_OPENED_FOR_ERASE = 8
    FT_DEVICE_NOT_OPENED_FOR_WRITE = 9
    FT_FAILED_TO_WRITE_DEVICE = 10
    FT_EEPROM_READ_FAILED = 11
    FT_EEPROM_WRITE_FAILED = 12
    FT_EEPROM_ERASE_FAILED = 13
    FT_EEPROM_NOT_PRESENT = 14
    FT_EEPROM_NOT_PROGRAMMED = 15
    FT_INVALID_ARGS = 16
    FT_NOT_SUPPORTED = 17
    FT_OTHER_ERROR = 18
    FT_DEVICE_LIST_NOT_READY = 19

FT_OK = 0
FT_INVALID_HANDLE = 1
FT_DEVICE_NOT_FOUND = 2
FT_DEVICE_NOT_OPENED = 3
FT_IO_ERROR = 4
FT_INSUFFICIENT_RESOURCES = 5
FT_INVALID_PARAMETER = 6

FT_HANDLE = c_void_p

FT_OPEN_BY_SERIAL_NUMBER = 1
FT_OPEN_BY_DESCRIPTION = 2
FT_OPEN_BY_LOCATION = 4


FT_FLOW_NONE = 0x0000
FT_FLOW_RTS_CTS = 0x0100
FT_FLOW_DTR_DSR = 0x0200
FT_FLOW_XON_XOFF = 0x0400

FT_BITMODE_RESET = 0x00
FT_BITMODE_ASYNC_BITBANG = 0x01
FT_BITMODE_MPSSE = 0x02
FT_BITMODE_SYNC_BITBANG = 0x04
FT_BITMODE_MCU_HOST = 0x08
FT_BITMODE_FAST_SERIAL = 0x10
FT_BITMODE_CBUS_BITBANG = 0x20
FT_BITMODE_SYNC_FIFO = 0x40


class FT_DEVICE_LIST_INFO_NODE(Structure):
    _fields_ = [
        ('Flags', c_int),
        ('Type', c_int),
        ('ID', c_int),
        ('LocID', c_int),
        ('SerialNumber', c_char * 16),
        ('Description', c_char * 64),
        ('ftHandle', FT_HANDLE),
    ]


# /*MPSSE Control Commands*/
MPSSE_CMD_SET_DATA_BITS_LOWBYTE = 0x80
MPSSE_CMD_SET_DATA_BITS_HIGHBYTE = 0x82
MPSSE_CMD_GET_DATA_BITS_LOWBYTE = 0x81
MPSSE_CMD_GET_DATA_BITS_HIGHBYTE = 0x83

MPSSE_CMD_SEND_IMMEDIATE = 0x87
MPSSE_CMD_ENABLE_3PHASE_CLOCKING = 0x8C
MPSSE_CMD_DISABLE_3PHASE_CLOCKING = 0x8D
MPSSE_CMD_ENABLE_DRIVE_ONLY_ZERO = 0x9E


# /*MPSSE Data Commands - bit mode - MSB first */
MPSSE_CMD_DATA_OUT_BITS_POS_EDGE = 0x12
MPSSE_CMD_DATA_OUT_BITS_NEG_EDGE = 0x13
MPSSE_CMD_DATA_IN_BITS_POS_EDGE = 0x22
MPSSE_CMD_DATA_IN_BITS_NEG_EDGE = 0x26
MPSSE_CMD_DATA_BITS_IN_POS_OUT_NEG_EDGE = 0x33
MPSSE_CMD_DATA_BITS_IN_NEG_OUT_POS_EDGE = 0x36


# /*MPSSE Data Commands - byte mode - MSB first * /
MPSSE_CMD_DATA_OUT_BYTES_POS_EDGE = 0x10
MPSSE_CMD_DATA_OUT_BYTES_NEG_EDGE = 0x11
MPSSE_CMD_DATA_IN_BYTES_POS_EDGE = 0x20
MPSSE_CMD_DATA_IN_BYTES_NEG_EDGE = 0x24
MPSSE_CMD_DATA_BYTES_IN_POS_OUT_NEG_EDGE = 0x31
MPSSE_CMD_DATA_BYTES_IN_NEG_OUT_POS_EDGE = 0x34


# /*SCL & SDA directions * /
DIRECTION_SCLIN_SDAIN = 0x10
DIRECTION_SCLOUT_SDAIN = 0x11
DIRECTION_SCLIN_SDAOUT = 0x12
DIRECTION_SCLOUT_SDAOUT = 0x13

# /*SCL & SDA values * /
VALUE_SCLLOW_SDALOW = 0x00
VALUE_SCLHIGH_SDALOW = 0x01
VALUE_SCLLOW_SDAHIGH = 0x02
VALUE_SCLHIGH_SDAHIGH = 0x03

# /*Data size in bits * /
DATA_SIZE_8BITS = 0x07
DATA_SIZE_1BIT = 0x00

'''/* The I2C master should actually drive the SDA line only when the output is LOW. It should
tristate the SDA line when the output should be high. This tristating the SDA line during high
output is supported only in FT232H chip. This feature is called DriveOnlyZero feature and is
enabled when the following bit is set in the options parameter in function I2C_Init * /'''
I2C_ENABLE_DRIVE_ONLY_ZERO = 0x0002

# /*clock*/
SET_LOW_BYTE_DATA_BITS_CMD = 0x80
GET_LOW_BYTE_DATA_BITS_CMD = 0x81
SET_HIGH_BYTE_DATA_BITS_CMD = 0x82
GET_HIGH_BYTE_DATA_BITS_CMD = 0x83
SET_CLOCK_FREQUENCY_CMD = 0x86
SET_LOW_BYTE_DATA_BITS_DATA = 0x13
SET_HIGH_BYTE_DATA_BITS_DATA = 0x0F
DISABLE_CLOCK_DIVIDE = 0x8A
ENABLE_CLOCK_DIVIDE = 0x8B

SLAVE_PREPARE_DURATION = 5
START_DURATION_1 = 10
START_DURATION_2 = 5

STOP_DURATION_1 = 10
STOP_DURATION_2 = 10
STOP_DURATION_3 = 10

RESTART_DURATION = 10
# START_DURATION_1 = 20
# START_DURATION_2 = 40

# STOP_DURATION_1 = 20
# STOP_DURATION_2 = 20
# STOP_DURATION_3 = 20

# RESTART_DURATION = 20
SEND_ACK = 0x00
SEND_NACK = 0x80

I2C_ADDRESS_READ_MASK = 0x01   # /*LSB 1 = Read*/
I2C_ADDRESS_WRITE_MASK = 0xFE  # /*LSB 0 = Write*/


SPI_DIRECTION = 0x0B


# Word Lengths

FT_BITS_8 = 8
FT_BITS_7 = 7


# Stop Bits

FT_STOP_BITS_1 = 0
FT_STOP_BITS_2 = 2

# Parity

FT_PARITY_NONE = 0
FT_PARITY_ODD = 1
FT_PARITY_EVEN = 2
FT_PARITY_MARK = 3
FT_PARITY_SPACE = 4

# Flow Control

FT_FLOW_NONE = 0x0000
FT_FLOW_RTS_CTS = 0x0100
FT_FLOW_DTR_DSR = 0x0200
FT_FLOW_XON_XOFF = 0x0400


class FT_Exception(Exception):
    pass


if __name__ == '__main__':
    # print(FT_DEVICE_LIST_INFO_NODE.ftHandle)
    # for dev in FT_DEVICE:
    #     print(dev, dev.value)
    # print((FT_DEVICE(8)))
    print(c_char(b'\x02'))
